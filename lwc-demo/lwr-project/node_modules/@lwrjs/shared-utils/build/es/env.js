if (getFeatureFlags().REEVALUATE_MODULES && !getFeatureFlags().LEGACY_LOADER) {
    throw new Error('REEVALUATE_MODULES is only supported with LEGACY_LOADER');
}
export function getFeatureFlags() {
    // Add any new feature flags here to parse from environment variables
    return {
        // Should we load load the assets from the lambda on MRT
        ASSETS_ON_LAMBDA: process.env.ASSETS_ON_LAMBDA !== undefined &&
            process.env.ASSETS_ON_LAMBDA.toLowerCase() === 'true'
            ? true
            : false,
        // DEFAULT LEGACY_LOADER = false;
        LEGACY_LOADER: process.env.LEGACY_LOADER !== undefined && process.env.LEGACY_LOADER.toLowerCase() === 'true'
            ? true
            : false,
        // SSR should concatenate bundles, default = false
        SSR_STATIC_BUNDLES: process.env.SSR_STATIC_BUNDLES !== undefined &&
            process.env.SSR_STATIC_BUNDLES.toLowerCase() === 'true'
            ? true
            : false,
        // Islands fallback to CSR if SSR fails
        SSR_WITH_CSR_FALLBACK: process.env.SSR_WITH_CSR_FALLBACK !== undefined &&
            process.env.SSR_WITH_CSR_FALLBACK.toLowerCase() === 'true'
            ? true
            : false,
        // AMD Module Bundles include un-versioned aliases
        EXPERIMENTAL_UNVERSIONED_ALIASES: process.env.EXPERIMENTAL_UNVERSIONED_ALIASES !== undefined &&
            process.env.EXPERIMENTAL_UNVERSIONED_ALIASES.toLowerCase() === 'true'
            ? true
            : false,
        LWR_TRACING: process.env.LWR_TRACING !== undefined && process.env.LWR_TRACING.toLowerCase() !== 'off'
            ? process.env.LWR_TRACING
            : false,
        ENABLE_NONCE: process.env.ENABLE_NONCE !== undefined && process.env.ENABLE_NONCE.toLowerCase() === 'true'
            ? true
            : false,
        // Forces SSR rendering to render only one page at a time
        SINGLE_RENDER_MODE: process.env.SINGLE_RENDER_MODE !== undefined &&
            process.env.SINGLE_RENDER_MODE.toLowerCase() === 'true'
            ? true
            : false,
        // Forces SSR to re-evaluate modules for every page render. By default, modules are evaluated only once.
        REEVALUATE_MODULES: process.env.REEVALUATE_MODULES !== undefined &&
            process.env.REEVALUATE_MODULES.toLowerCase() === 'true'
            ? true
            : false,
        MAX_VIEW_CACHE_TTL: process.env.MAX_VIEW_CACHE_TTL,
    };
}
/**
 * This function is used to determine if the current environment is a lambda.
 *
 * @returns true if process is running in lambda environment
 */
export function isLambdaEnv() {
    return process.env.AWS_LAMBDA_FUNCTION_NAME !== undefined;
}
/**
 * This function is used to determine if lwr is running in the context of local development.
 *
 * @returns true if running in localdev mode
 */
export function isLocalDev() {
    // TODO still need to formalize environment variable names
    return process.env.MRT_HMR === 'true';
}
/**
 * Create a serializable context for user-land exposed environment variables
 */
export function buildEnvironmentContext(runtimeParams) {
    // The baseBath from the config or set from the request (e.g. /shop)
    const basePath = runtimeParams.basePath;
    // The locale set from the request or the defaultLocale from the config (e.g. en-US)
    const locale = runtimeParams.locale;
    // Root base path for static assets (e.g. /shop/mobify/bundle/1234/site)
    const assetBasePath = runtimeParams.assetBasePath;
    // Base path for UI routing (e.g. /shop/en-US)
    const uiBasePath = runtimeParams.uiBasePath;
    return {
        basePath,
        locale,
        assetBasePath,
        uiBasePath,
    };
}
export const REQUEST_DEPTH_HEADER = 'X-SFDC-Request-Depth';
export const REQUEST_DEPTH_KEY = REQUEST_DEPTH_HEADER.toLowerCase();
export function parseRequestDepthHeader(headers = {}) {
    let maxDepth = 0;
    const value = headers && headers[REQUEST_DEPTH_KEY];
    if (value) {
        if (Array.isArray(value)) {
            for (const depth of value) {
                if (typeof depth === 'string') {
                    const depthValue = parseInt(depth, 10);
                    if (!isNaN(depthValue) && depthValue > maxDepth) {
                        maxDepth = depthValue;
                    }
                }
            }
        }
        else if (typeof value === 'string') {
            const depth = parseInt(value, 10);
            if (!isNaN(depth) && depth > maxDepth) {
                maxDepth = depth;
            }
        }
    }
    return maxDepth;
}
//# sourceMappingURL=env.js.map