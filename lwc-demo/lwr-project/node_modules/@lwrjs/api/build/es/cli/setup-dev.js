import fs from 'fs-extra';
import path from 'path';
import { logger } from '@lwrjs/diagnostics';
import * as tar from 'tar';
import { spawn } from 'child_process';
async function npmInstall(directoryPath) {
    const fullPath = path.resolve(directoryPath);
    logger.info(`Running 'npm install' in directory: ${fullPath}`);
    return new Promise((resolve, reject) => {
        const npmProcess = spawn('npm', ['install'], { cwd: fullPath, shell: true });
        npmProcess.stdout.on('data', (data) => {
            logger.info(`stdout: ${data}`);
        });
        npmProcess.stderr.on('data', (data) => {
            logger.error(`stderr: ${data}`);
        });
        npmProcess.on('close', (code) => {
            if (code === 0) {
                logger.info(`'npm install' completed successfully in directory: ${fullPath}`);
                resolve();
            }
            else {
                const error = new Error(`'npm install' failed with code ${code}`);
                logger.error(error.message);
                reject(error);
            }
        });
        npmProcess.on('error', (error) => {
            logger.error(`Error running 'npm install': ${error.message}`);
            reject(error);
        });
    });
}
export async function setupDev(options) {
    // If we don't have a bundle and the directory doesn't exist, throw error
    if (!options.mrtBundle && !fs.existsSync(path.join(options.mrtDir, 'ssr.js'))) {
        throw new Error(`MRT bundle '${options.mrtBundle}' does not exist`);
    }
    // if we do have a bundle and directory doesn't exist, extract it
    if (options.mrtBundle && !fs.existsSync(path.join(options.mrtDir, 'ssr.js'))) {
        logger.info(`Extracting -> '${options.mrtBundle}'`);
        // Cleanup old directories
        fs.rmSync(options.mrtDir, { recursive: true, force: true });
        fs.rmSync('bld', { recursive: true, force: true });
        // Extract
        await tar.x({
            file: options.mrtBundle,
        });
        // Rename to proper name
        fs.renameSync('bld', options.mrtDir);
    }
    // If we don't have a valid ssr.js file at this point, error out
    if (!fs.existsSync(path.join(options.mrtDir, 'ssr.js'))) {
        throw new Error(`MRT bundle '${options.mrtBundle}' does not exist`);
    }
    // Setup proxy file
    const proxyPath = path.join(options.mrtDir, 'config', '_proxy');
    if (!fs.existsSync(proxyPath) && options.proxyUrl) {
        // TODO does this need customized depending on internal vs external?
        fs.writeFileSync(proxyPath, `/services ${options.proxyUrl}` +
            `\n/sfsites ${options.proxyUrl}` +
            `\n/webruntime ${options.proxyUrl}` +
            `\n/mobify/proxy/core ${options.proxyUrl}`);
    }
    // Update the package.json file to include lwc as a dependency with the correct version
    const ssrjsPath = path.join(options.mrtDir, 'ssr.js');
    // Get LWC version from ssr.js
    const versions = getVersions(ssrjsPath);
    if (versions.LWC_VERSION) {
        logger.info(`setting up lwc'`);
        const packageJsonPath = path.join(options.mrtDir, 'package.json');
        const packageJsonContent = fs.readJSONSync(packageJsonPath);
        packageJsonContent.dependencies = packageJsonContent.dependencies || {};
        packageJsonContent.dependencies['lwc'] = versions.LWC_VERSION;
        fs.writeJsonSync(packageJsonPath, packageJsonContent, { spaces: 4 });
        // Run npm install from the mrt directory to get correct LWC version
        if (options.npmInstall) {
            try {
                await npmInstall(options.mrtDir);
                logger.info('npm install completed successfully');
            }
            catch (error) {
                logger.error('Failed to run npm install:', error);
            }
        }
    }
}
function getVersions(filePath) {
    const lwrVersionRegex = /globalThis\.LWR_VERSION='([^']+)';/g;
    const lwcVersionRegex = /globalThis\.LWC_VERSION='([^']+)';/g;
    const content = fs.readFileSync(filePath, 'utf-8');
    const versions = {
        LWR_VERSION: '',
        LWC_VERSION: '',
    };
    const result = lwrVersionRegex.exec(content);
    versions.LWR_VERSION = result ? result[0] : '';
    const lwcResult = lwcVersionRegex.exec(content);
    versions.LWC_VERSION = lwcResult ? lwcResult[0] : '';
    if (!versions.LWR_VERSION || !versions.LWC_VERSION) {
        throw new Error('Could not find all version strings in the file');
    }
    logger.info('versions', versions);
    return versions;
}
//# sourceMappingURL=setup-dev.js.map