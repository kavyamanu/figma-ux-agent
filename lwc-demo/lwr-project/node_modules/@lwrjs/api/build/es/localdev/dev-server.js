import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';
import proxy from 'http-proxy-middleware';
import { createServer } from '@lwrjs/core';
import express from 'express';
import { loadConfig } from '@lwrjs/config';
import { logger } from '@lwrjs/diagnostics';
import { crossEnvFileURL } from '@lwrjs/shared-utils';
export async function createDevServer(port, bundleProdDir) {
    // TEMP: need to define official directory name for local LWR@MRT bundle
    process.env.MRT_BUNDLE_ROOT = 'app';
    process.env.ENABLE_NONCE = 'false';
    // disables `createHandler` invocation while loading application build output
    process.env.LOCAL = 'true';
    // TODO: remove once W-16104831 is resolved
    process.env.REEVALUATE_MODULES = 'true';
    const configPath = crossEnvFileURL(path.join(process.cwd(), 'app', 'ssr.js'));
    const { MRT_APP_CONFIG: { appConfig }, } = await import(configPath);
    // Allow a local lwr.config.json file to specify the additional route paths for commerce packaging
    const staticSiteGenerator = {
        ...appConfig.staticSiteGenerator,
        outputDir: path.join('app', appConfig.staticSiteGenerator.outputDir),
    };
    if (bundleProdDir) {
        try {
            const aConfig = loadConfig({ rootDir: process.cwd() });
            staticSiteGenerator._additionalRoutePaths =
                aConfig.appConfig?.staticSiteGenerator?._additionalRoutePaths || [];
        }
        catch (e) {
            logger.info({
                label: 'local-dev server',
                message: 'no additional route paths to load',
            });
        }
    }
    // TEMP: need to move providers(and maybe the dev server) out to a new package
    const __dirname = path.dirname(fileURLToPath(import.meta.url));
    let hooks = [path.join(__dirname, 'hooks', 'dev-context-hook.js')];
    let bundleProviders = [
        path.join(__dirname, 'providers', 'override-bundle-provider.js'),
        // '@lwrjs/module-bundler/amd-runtime-bundle-provider',
        '@lwrjs/module-bundler/amd-bundle-provider',
    ];
    if (bundleProdDir) {
        hooks = [path.join(__dirname, 'hooks', 'prod-context-hook.js')];
        bundleProviders = [
            [
                path.join(__dirname, 'providers', 'override-bundle-provider.js'),
                { writeProdBundlesDir: bundleProdDir },
            ],
            // Use esbuild / proper minification
            '@lwrjs/module-bundler/amd-bundle-provider',
        ];
    }
    let lwcCompiler;
    const lwcCompilerPath = path.join(process.cwd(), 'app', 'localdev', 'lwc-compiler.js');
    if (fs.existsSync(lwcCompilerPath)) {
        try {
            // Try to import the LWC compiler from the MRT bundle, so
            // we can compile hot modules with a matching LWC version
            lwcCompiler = await import(crossEnvFileURL(lwcCompilerPath));
        }
        catch (e) {
            // Fallback to use the @lwc/compiler imported by the @lwr/lwc-module-provider package
            logger.warn({
                label: 'local-dev server',
                message: 'Could not import @lwc/compiler from the MRT bundle',
                additionalInfo: e,
            });
        }
    }
    else {
        logger.warn({
            label: 'local-dev server',
            message: 'Application does not contain a bundled @lwc/compiler',
        });
    }
    const app = createServer({
        ...appConfig,
        ignoreLwrConfigFile: true,
        rootDir: process.cwd(),
        cacheDir: path.join(process.cwd(), '__lwr_cache__'),
        lwc: { modules: [...appConfig.lwc.modules, { dir: path.join(__dirname, 'modules') }] },
        moduleProviders: [
            path.join(__dirname, 'providers', 'alias-static-module-provider.js'),
            '@lwrjs/module-registry/externals-module-provider',
            [path.join(__dirname, 'providers', 'evergreen-lwc-module-provider.js'), { lwcCompiler }],
            [path.join(__dirname, 'providers', 'sfdx-module-provider.js'), { lwcCompiler }],
            path.join(__dirname, 'providers', 'fallthrough-module-provider.js'),
        ],
        bundleProviders,
        assetProviders: ['@lwrjs/static/asset-provider'],
        assetTransformers: [],
        resourceProviders: ['@lwrjs/static/resource-provider'],
        uriTransformers: ['@lwrjs/lambda/mrt-static-uri-transformer'],
        hooks,
        staticSiteGenerator,
        port,
        routeHandlers: {},
        routes: [],
    });
    const server = app.getInternalServer();
    // TEMP: need to support locales
    server.use('/mobify/bundle/development/app/site/prod/view/en-US/', express.static(path.join(process.cwd(), '__lwr_cache__', 'overrides')));
    // If we serve up dev bundles, we need to use overrides as well
    server.use('/mobify/bundle/development/app/site/dev/view/en-US/', express.static(path.join(process.cwd(), '__lwr_cache__', 'overrides')));
    server.use('/mobify/bundle/development/app/site', express.static(path.join(process.cwd(), './app/site')));
    // TODO replicate behaviour of dev-proxy-server
    let proxyFile = path.join(process.cwd(), './app/config/_proxy');
    if (!fs.existsSync(proxyFile))
        proxyFile = path.join(process.cwd(), './config/_proxy');
    if (fs.existsSync(proxyFile)) {
        const proxyConfig = fs.readFileSync(proxyFile).toString().trim().split('\n');
        for (const entry of proxyConfig) {
            const [entryPath, target] = entry.split(' ');
            // Needed for commerce local-dev when running mrt bundles without a configured cloudflare CDN
            // rewrites /mobify/proxy/core and /mobify/caching/core paths (this is what pwa-kit does)
            const pathRewrite = entryPath.indexOf('/mobify/proxy') === 0 || entryPath.indexOf('/mobify/caching') === 0
                ? { [entryPath]: '' }
                : undefined;
            server.use(entryPath, proxy({
                target,
                pathRewrite,
                followRedirects: false,
                changeOrigin: true,
            }));
        }
    }
    return app;
}
//# sourceMappingURL=dev-server.js.map