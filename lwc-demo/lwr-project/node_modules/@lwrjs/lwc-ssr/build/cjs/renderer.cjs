var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/lwc-ssr/src/renderer.ts
__markAsModule(exports);
__export(exports, {
  Renderer: () => Renderer,
  getRenderer: () => getRenderer
});
var import_lru_cache = __toModule(require("lru-cache"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_instrumentation = __toModule(require("@lwrjs/instrumentation"));
var import_utils = __toModule(require("./utils.cjs"));
var import_moduleLoader = __toModule(require("./moduleLoader.cjs"));
var import_serverBootstrapServices = __toModule(require("./serverBootstrapServices.cjs"));
var singleton;
function getRenderer(config, bundleRegistry, resourceRegistry) {
  if (!singleton) {
    singleton = new Renderer(config, bundleRegistry, resourceRegistry);
  }
  return singleton;
}
var Renderer = class {
  constructor(config, bundleRegistry, resourceRegistry) {
    this.config = config;
    this.bundleRegistry = bundleRegistry;
    this.resourceRegistry = resourceRegistry;
    this.contextPerEnv = new import_lru_cache.LRUCache({
      max: 50,
      dispose: () => {
        import_diagnostics.logger.info("evicted bootstrap context from renderer cache");
      }
    });
    const taskPoolSize = (0, import_shared_utils.getFeatureFlags)().SINGLE_RENDER_MODE ? 1 : 15;
    this.pendingRenders = new import_shared_utils.TaskPool(taskPoolSize);
  }
  async render(components, route, runtimeEnvironment, runtimeParams, serverData = {}, isFirstOf2PassSSR) {
    let result;
    if ((0, import_shared_utils.isLambdaEnv)() || process.env.SSR_TIMEOUT !== void 0) {
      let timerId;
      const timeout = new Promise((_, reject) => {
        timerId = setTimeout(() => {
          reject((0, import_diagnostics.createSingleDiagnosticError)({
            description: import_diagnostics.descriptions.UNRESOLVABLE.SSR_TIMEOUT(route.id, (0, import_utils.getRenderTimeout)())
          }, import_diagnostics.LwrUnresolvableError));
        }, (0, import_utils.getRenderTimeout)());
      });
      result = await this.pendingRenders.execute(async () => {
        return Promise.race([
          timeout,
          this.renderComponents(components, route, runtimeEnvironment, runtimeParams, serverData, isFirstOf2PassSSR)
        ]);
      });
      clearTimeout(timerId);
    } else {
      result = await this.pendingRenders.execute(async () => {
        return this.renderComponents(components, route, runtimeEnvironment, runtimeParams, serverData, isFirstOf2PassSSR);
      });
    }
    return result;
  }
  async renderComponents(components, route, runtimeEnvironment, runtimeParams, serverData = {}, isFirstOf2PassSSR = false) {
    const results = {};
    const errors = {};
    const roots = Object.keys(components);
    const services = (0, import_utils.getServerBootstrapServices)(route);
    const reevaluateModules = (0, import_shared_utils.getFeatureFlags)().REEVALUATE_MODULES === true;
    const singleRenderMode = (0, import_shared_utils.getFeatureFlags)().SINGLE_RENDER_MODE;
    let loader, loaderPromise, bootstrapServiceEvaluationMap;
    try {
      const bootstrapContext = this.getCachedBootstrapContext(route, runtimeEnvironment, runtimeParams, serverData, reevaluateModules);
      loaderPromise = bootstrapContext.loader;
      bootstrapServiceEvaluationMap = bootstrapContext.bootstrapServiceEvaluationMap;
      loader = await loaderPromise;
      loader.getFetchController().disableFetchKillSwitch();
      const engineServerSpecifier = (0, import_shared_utils.getSpecifier)({
        specifier: "@lwc/engine-server",
        version: route.bootstrap.lwcVersion
      });
      const engine = await loader.load(engineServerSpecifier, ["lwc"]);
      const shouldRunBootstrapServices = !bootstrapServiceEvaluationMap?.has(route.id);
      let serverBootstrapServices;
      if (shouldRunBootstrapServices) {
        bootstrapServiceEvaluationMap?.set(route.id, true);
        const serviceModules = await Promise.all(services.map((specifier) => loader?.load(specifier)));
        serverBootstrapServices = (0, import_serverBootstrapServices.createServerBootstrapServices)(loader);
        for (const service of serviceModules) {
          const error = await (0, import_serverBootstrapServices.evaluateServerBootstrapModule)(service, serverBootstrapServices.serviceAPI);
          if (error) {
            errors[service.specifier] = error;
          }
        }
      }
      const componentModules = await Promise.all(roots.map((specifier) => loader?.load(specifier)));
      for (const component of componentModules) {
        const {props} = components[component.specifier];
        if (!component.module.getServerData) {
          results[component.specifier] = {props};
          continue;
        }
        const context = {
          props,
          url: runtimeParams.url,
          params: runtimeParams.params || {},
          query: runtimeParams.query || {},
          locale: runtimeParams.locale || runtimeEnvironment.i18n?.defaultLocale,
          basePath: runtimeParams.basePath || runtimeEnvironment.basePath
        };
        const {data, error} = await getServerData(component, context, serverData);
        if (error) {
          errors[component.specifier] = error;
          continue;
        }
        if (data) {
          results[component.specifier] = data;
        }
      }
      if (serverBootstrapServices) {
        serverBootstrapServices.evaluateServerDataHooks(serverData);
      }
      if (!route.bootstrap.ssr) {
        if (Object.keys(errors).length) {
          return {results, errors};
        }
        return {results};
      }
      if ((0, import_shared_utils.getFeatureFlags)().SINGLE_RENDER_MODE) {
        loader.getFetchController().enableNoOpFetch();
      }
      for (const component of componentModules) {
        if (errors[component.specifier]) {
          continue;
        }
        const {html, error} = renderToString(engine.module, component, results[component.specifier].props);
        if (error) {
          errors[component.specifier] = error;
          continue;
        }
        results[component.specifier].html = html;
      }
      if (Object.keys(errors).length) {
        return {results, errors};
      }
      return {results};
    } catch (e) {
      const error = Object(e);
      return {
        errors: {
          [roots.join(",")]: error.message ?? (0, import_diagnostics.stringifyError)(e)
        }
      };
    } finally {
      if (singleRenderMode) {
        loader?.getFetchController().disableNoOpFetch();
        loader?.getFetchController().enableFetchKillSwitch();
      }
      if (!isFirstOf2PassSSR) {
        loader?.resetGlobalContext();
        if (reevaluateModules) {
          bootstrapServiceEvaluationMap?.delete(route.id);
          loader?.clearRegistry();
        }
      }
    }
  }
  getCachedBootstrapContext(route, runtimeEnvironment, runtimeParams, serverData, reevaluateModules) {
    let loader, bootstrapServiceEvaluationMap;
    if (reevaluateModules) {
      if (!this.cachedBootstrapContext) {
        this.cachedBootstrapContext = {
          loader: (0, import_moduleLoader.createModuleLoader)(this.config, this.resourceRegistry, this.bundleRegistry, runtimeEnvironment, runtimeParams, serverData, route.bootstrap),
          bootstrapServiceEvaluationMap: new Map()
        };
      }
      return this.cachedBootstrapContext;
    }
    const envContext = (0, import_shared_utils.buildEnvironmentContext)(runtimeParams);
    const {host, requestDepth} = runtimeParams;
    const contextCacheKey = (0, import_shared_utils.getCacheKeyFromJson)({envContext, host, requestDepth});
    const bootstrapContext = this.contextPerEnv.get(contextCacheKey);
    if (!bootstrapContext) {
      loader = (0, import_moduleLoader.createModuleLoader)(this.config, this.resourceRegistry, this.bundleRegistry, runtimeEnvironment, runtimeParams, serverData, route.bootstrap);
      bootstrapServiceEvaluationMap = new Map();
      this.contextPerEnv.set(contextCacheKey, {
        loader,
        bootstrapServiceEvaluationMap
      });
    } else {
      loader = bootstrapContext.loader;
      bootstrapServiceEvaluationMap = bootstrapContext.bootstrapServiceEvaluationMap;
    }
    return {
      loader,
      bootstrapServiceEvaluationMap
    };
  }
};
function getServerData(component, context, serverData) {
  return (0, import_instrumentation.getTracer)().trace({
    name: import_instrumentation.ViewSpan.GetServerData,
    attributes: {specifier: component.specifier}
  }, async () => {
    try {
      const data = await component.module.getServerData(context);
      Object.assign(serverData, data.props);
      return {data};
    } catch (e) {
      const message = `Error in "getServerData" for "${component.specifier}": ${(0, import_diagnostics.stringifyError)(e)}`;
      import_diagnostics.logger.error(message);
      return {error: message};
    }
  });
}
function renderToString(engine, component, props) {
  return (0, import_instrumentation.getTracer)().trace({
    name: import_instrumentation.ViewSpan.RenderComponent,
    attributes: {specifier: component.specifier}
  }, () => {
    try {
      const html = engine.renderComponent((0, import_shared_utils.moduleSpecifierToKebabCase)(component.specifier), component.module.default, props);
      return {html};
    } catch (e) {
      const error = Object(e);
      const message = error.message ?? (0, import_diagnostics.stringifyError)(e);
      const detailedMessage = error.wcStack ? "An error occurred during server-side rendering for component stack: " + error.wcStack + ". Error was: " + message : `An error occurred during server-side rendering "${component.specifier}": ` + message;
      import_diagnostics.logger.error(detailedMessage);
      return {error: detailedMessage};
    }
  });
}
