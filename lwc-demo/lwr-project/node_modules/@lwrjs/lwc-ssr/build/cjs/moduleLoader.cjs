var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/lwc-ssr/src/moduleLoader.ts
__markAsModule(exports);
__export(exports, {
  FETCH_ABORT_KEY: () => FETCH_ABORT_KEY,
  createModuleLoader: () => createModuleLoader
});
var import_path = __toModule(require("path"));
var import_crypto = __toModule(require("crypto"));
var import_instrumentation = __toModule(require("@lwrjs/instrumentation"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_utils = __toModule(require("./utils.cjs"));
var FETCH_ABORT_KEY = "__fetchAbortId__";
var BOOTSTRAP_SPECIFIER = "@lwrjs/ssr-bootstrap";
function createModuleLoader(config, resourceRegistry, bundleRegistry, runtimeEnvironment, runtimeParams, serverData, bootstrapConfig) {
  const createLoader = runtimeEnvironment.format === "amd" ? createAMDModuleLoader : createESMModuleLoader;
  return createLoader(config, resourceRegistry, bundleRegistry, runtimeEnvironment, runtimeParams, serverData, bootstrapConfig);
}
async function createAMDModuleLoader(config, resourceRegistry, bundleRegistry, runtimeEnvironment, runtimeParams, serverData, bootstrapConfig) {
  const loaderConfig = (0, import_utils.getLoaderConfig)(BOOTSTRAP_SPECIFIER, config, runtimeParams, serverData);
  const {context, controller} = createContext(loaderConfig, runtimeParams);
  const contextKeyMap = new Map(Object.keys(context).map((key) => [key, true]));
  let run;
  context.LWR.customInit = async (lwr) => {
    run = lwr.initializeApp;
  };
  const useEval = process.env.SSR_DEBUG === "true";
  const init = (source) => {
    if (!useEval) {
      const fn = new Function("globalThis", ...Object.keys(context), source);
      fn(context, ...Object.values(context));
    } else {
      ((context) => {
        eval(`${Object.keys(context).reduce((c, k) => c + `const ${k} = context['${k}'];`, "globalThis=context;")} ${source}`);
      })(context);
    }
  };
  init(await (0, import_utils.getLoaderShim)(resourceRegistry, runtimeEnvironment, bootstrapConfig));
  if (!run) {
    throw new Error("Failed to init loader shim: custom init not called");
  }
  const p = new Promise((resolve) => {
    context.LWR.define(BOOTSTRAP_SPECIFIER, [(0, import_utils.getLoaderId)(context.LWR, bootstrapConfig)], (l) => resolve(l));
  });
  run();
  const {load, services, clearRegistry} = await p;
  const visited = new Set(["lwc"]);
  return {
    services,
    clearRegistry,
    load: async (specifier, aliases) => {
      const injectBundle = async (bundle, aliases2) => {
        if (visited.has(bundle) && specifier !== bundle) {
          return;
        }
        visited.add(bundle);
        const moduleId = (0, import_shared_utils.explodeSpecifier)(bundle);
        const def = await bundleRegistry.getModuleBundle(moduleId, runtimeEnvironment, runtimeParams);
        if (typeof def.src === "string" && !def.code.includes("//# sourceURL=")) {
          const srcUrl = (0, import_shared_utils.isLocalDev)() ? (0, import_shared_utils.getLocalDevOverrideUrl)(config.cacheDir, moduleId.specifier, def.src) : def.src;
          def.code += `
//# sourceURL=${import_path.default.resolve(srcUrl)}`;
        }
        const staticImports = def.bundleRecord.imports?.map((dep) => (0, import_shared_utils.getSpecifier)(dep)) ?? [];
        const dynamicImports = def.bundleRecord.dynamicImports?.map((dep) => (0, import_shared_utils.getSpecifier)(dep)) ?? [];
        if (staticImports.length || dynamicImports.length) {
          await Promise.all([...staticImports, ...dynamicImports].map((dep) => injectBundle(dep)));
        }
        init(def.code);
        if (aliases2?.length) {
          for (const alias of aliases2) {
            context.LWR.define(alias, [def.id], (mod2) => mod2);
            context.LWR.define((0, import_shared_utils.getSpecifier)({
              specifier: alias,
              version: def.version
            }), [def.id], (mod2) => mod2);
          }
        }
        if (def.specifier.startsWith("@app") || def.specifier.startsWith("@salesforce")) {
          context.LWR.define((0, import_shared_utils.getSpecifier)(def), [def.specifier], (mod2) => mod2);
        }
        return def;
      };
      const injected = await injectBundle(specifier, aliases);
      if (!injected) {
        throw new Error(`Failed to inject bundle ${specifier}`);
      }
      const mod = await load(injected.id);
      return {
        specifier: injected.specifier,
        module: mod
      };
    },
    getFetchController: () => controller,
    resetGlobalContext: () => {
      for (const key in context) {
        if (Object.prototype.hasOwnProperty.call(context, key) && !contextKeyMap.has(key)) {
          delete context[key];
        }
      }
      context.LWR = {
        ...context.LWR,
        serverData: void 0
      };
    },
    getContext: () => {
      return context;
    }
  };
}
async function createESMModuleLoader() {
  throw new Error("ESM support coming soon.");
}
function createContext(LWR, runtimeParams) {
  const tracer = (0, import_instrumentation.getTracer)();
  const trace = tracer.trace.bind(tracer);
  const fetchEndowment = (0, import_utils.createFetchEndowment)(trace, runtimeParams.host, runtimeParams.requestDepth);
  const fetchController = new import_utils.FetchController(fetchEndowment);
  const context = {
    LWR,
    lwcRuntimeFlags: {ENABLE_WIRE_SYNC_EMIT: true},
    crypto: import_crypto.default,
    CustomEvent: Event,
    fetch: fetchController.controlledFetch
  };
  return {
    context,
    controller: {
      enableNoOpFetch: () => {
        fetchController.activateNoOp();
      },
      disableNoOpFetch: () => {
        fetchController.deactivateNoOp();
      },
      enableFetchKillSwitch: () => {
        fetchController.activateKillSwitch();
      },
      disableFetchKillSwitch: () => {
        fetchController.deactivateKillSwitch();
      }
    }
  };
}
