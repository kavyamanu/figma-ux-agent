import { logger, stringifyError } from '@lwrjs/diagnostics';
import { ViewSpan } from '@lwrjs/instrumentation';
import { REQUEST_DEPTH_HEADER, buildEnvironmentContext, getFeatureFlags, normalizeVersionToUri, isLambdaEnv, } from '@lwrjs/shared-utils';
const DEFAULT_SSR_TIMEOUT = 5000; // 5 seconds, override with process.env.SSR_TIMEOUT
export const SSR_PROPS_ATTR = 'data-lwr-props-id';
export function getPropsId() {
    return `lwcprops${Math.floor(Math.random() * 0x10000).toString(16)}`;
}
export function getRenderTimeout() {
    const override = process.env.SSR_TIMEOUT;
    return override ? Number.parseInt(override) : DEFAULT_SSR_TIMEOUT;
}
export function createSsrErrorMessage(specifier, e) {
    return `Server-side rendering for "${specifier}" failed. Falling back to client-side rendering. Reason: ${stringifyError(e)}`;
}
export async function getLoaderShim(resourceRegistry, runtimeEnvironment, bootstrapConfig) {
    const { debug } = runtimeEnvironment;
    // debug resources are not available in deployed lambda env
    const useDebug = debug && !isLambdaEnv();
    const specifier = getFeatureFlags().LEGACY_LOADER
        ? useDebug
            ? 'lwr-loader-shim-legacy.bundle.js'
            : 'lwr-loader-shim-legacy.bundle.min.js'
        : useDebug
            ? 'lwr-loader-shim.bundle.js'
            : 'lwr-loader-shim.bundle.min.js';
    const resource = await resourceRegistry.getResource({ specifier, version: bootstrapConfig.lwrVersion }, runtimeEnvironment, 
    // HACK: this code is tricky because resource IDs are different between prod vs debug ("lwr-loader-shim.bundle.min.js" vs "lwr-loader-shim.bundle.js").
    // 1. In debug mode on Lambda (during SSR), we need to ignore runtimeEnvironment.debug because we will always ask for the prod version (lwr-loader-shim.bundle.min.js)
    // 2. But when we generate the view, we can't ignore runtimeEnvironment.debug because we need the debug version of the loader shim (lwr-loader-shim.bundle.js)
    { ignoreDebug: !useDebug });
    if (!resource?.content && !resource?.stream) {
        throw new Error('Failed to find the loader shim');
    }
    let result = '';
    if (resource.content) {
        result = resource.content;
    }
    else {
        const stream = resource.stream();
        for await (const chunk of stream) {
            result += chunk;
        }
    }
    result += `\n//# sourceURL=${resource.entry}`;
    return result;
}
export function getLoaderId(config, bootstrapConfig) {
    // TODO W-15509657 - hack: checking `requiredModules` because the loader may not be the same version as the current runtime
    if (config.requiredModules) {
        const id = config.requiredModules.find((specifier) => specifier.startsWith('lwr/loader'));
        if (id) {
            return id;
        }
    }
    // default to the active LWR version
    const version = normalizeVersionToUri(bootstrapConfig.lwrVersion);
    return getFeatureFlags().LEGACY_LOADER ? `lwr/loaderLegacy/v/${version}` : `lwr/loader/v/${version}`;
}
export function getLoaderConfig(bootstrapModule, config, runtimeParams, serverData) {
    return Object.assign({}, {
        bootstrapModule,
        serverData,
        autoBoot: false,
        disableInitDefer: true,
        rootComponents: [],
        endpoints: {
            uris: {
                mapping: `/1/mapping/amd/1/l/${runtimeParams.locale ?? config.i18n.defaultLocale}/mp/`,
            },
        },
        env: {
            ...buildEnvironmentContext(runtimeParams),
            SSR: true,
        },
    }, getFeatureFlags().LEGACY_LOADER
        ? {
            baseUrl: 'ssr',
        }
        : {
            baseUrl: '/',
            imports: {
                'any/thing.js': ['any/thing'],
            },
        });
}
export function getServerBootstrapServices(route) {
    return route.bootstrap.services.reduce((acc, service) => {
        if (service.ssr === true) {
            acc.push(service.name);
        }
        return acc;
    }, []);
}
/**
 * During SSR a context is created with a new fetchController. At this point any fetches work as expected in this context.
 *
 * Right before renderComponents we call activateNoOp. At this point any new fetch calls in this context result in a no-op
 * fetch waiting to be aborted.
 *
 * When SSR for this request is complete we call activateKillSwitch which aborts any pending fetch calls in this context.
 * Any new fetch calls (i.e. from other async function calls) would be immediately aborted.
 */
export class FetchController {
    constructor(fetchEndowment) {
        this.controlledFetch = (request, init) => {
            if (this.killSwitchActivated) {
                return this.handleAbortError(request, undefined);
            }
            const controller = new AbortController();
            // Ensure the init object exists and then add the signal to it.
            const updatedInit = { ...init, signal: controller.signal };
            this.controllers.add(controller);
            const fetchFunction = this.noOpActivated
                ? this.fetchNoOp(request, updatedInit)
                : this.fetchEndowment(request, updatedInit);
            const fetchPromise = fetchFunction
                .catch((error) => {
                // Check if the error is an AbortError
                if (error && error?.stack.startsWith('AbortError')) {
                    return this.handleAbortError(request, error);
                }
                else {
                    // Re-throw the error if it's not an AbortError
                    throw error;
                }
            })
                .finally(() => {
                this.controllers.delete(controller);
            });
            return fetchPromise;
        };
        /**
         * After SSR is complete the kill switch will abort any pending fetch requests.
         */
        this.activateKillSwitch = () => {
            this.killSwitchActivated = true;
            this.controllers.forEach((controller) => {
                controller.abort();
            });
            this.controllers.clear(); // Clear the set as all fetch calls have been aborted
        };
        this.deactivateKillSwitch = () => {
            this.killSwitchActivated = false;
        };
        /**
         * During SSR renderComponent (which is synchronous) Do not even call any fetch requests
         * since they would not complete before SSR is done.
         */
        this.activateNoOp = () => {
            this.noOpActivated = true;
        };
        this.deactivateNoOp = () => {
            this.noOpActivated = false;
        };
        this.killSwitchActivated = false;
        this.noOpActivated = false;
        this.controllers = new Set();
        this.fetchEndowment = fetchEndowment;
    }
    handleAbortError(request, error) {
        const message = `Orphaned ${String(request)} request was killed. Async processes are not supported during SSR. For more information, see: https://developer.salesforce.com/docs/platform/lwr/guide/lwr-configure-component-ssr.html.`;
        logger.warn({ label: `Server-side Rendering`, message }, error);
        // Return a response to indicate kill switch
        return Promise.resolve(new Response(message, { status: 500 }));
    }
    /**
     * Create a fetch API that never calls a request.
     * This is not expected to be called without an AbortController setup.
     */
    fetchNoOp(request, init) {
        return new Promise((resolve) => {
            if (!init?.signal) {
                // This should not happen?  This is only called internally to the class and we setup an abort controller.
                resolve(this.handleAbortError(request, new Error('RequestInit was not setup as expected')));
            }
            else if (init.signal.aborted) {
                // The request was already aborted go ahead and return the abort error
                resolve(this.handleAbortError(request, new Error('Request was aborted')));
            }
            else {
                // Wait until fetches are aborted to resolve with an abort error
                const abortHandler = (err) => {
                    init?.signal?.removeEventListener('abort', abortHandler);
                    // Resolve the fetch
                    resolve(this.handleAbortError(request, err));
                };
                init.signal.addEventListener('abort', abortHandler);
            }
        });
    }
}
export function createFetchEndowment(trace, host = '', requestCount = 1) {
    return (request, init) => {
        let finalRequest;
        let finalUrl;
        if (request instanceof Request) {
            const curUrl = request.url;
            // proxy relative URLs through the host
            if (curUrl.startsWith('/')) {
                finalUrl = host + curUrl;
                finalRequest = new Request(finalUrl, request);
            }
            else {
                finalUrl = curUrl;
                finalRequest = request;
            }
        }
        else {
            const curUrl = typeof request === 'string' ? request : request.toString(); // handle string-able types, eg: URL
            finalRequest = finalUrl = curUrl.startsWith('/') ? host + curUrl : curUrl; // proxy relative URLs through the host
        }
        const finalInit = {
            ...init,
            headers: {
                ...init?.headers,
                [REQUEST_DEPTH_HEADER]: String(requestCount),
            },
        };
        return trace({ name: ViewSpan.Fetch, attributes: { url: String(finalUrl) } }, () => 
        // this trace will NOT fail if fetch fails; it is meant to log the URLs fetched from the server
        // the fetch caller (ie: getServerData) should handle the error if response.ok is false
        // if the caller throws the fetch error, then it will be surfaced in the PARENT traces:
        // lwr.view.ssr.fetch (this) > lwr.view.ssr > lwr.view.ssr.island > lwr.view.render > lwr.handle.view
        fetch(finalRequest, finalInit));
    };
}
/** SSR HEAD MARKUP UTILS */
function createMetaTags(meta) {
    return meta.reduce((metaStr, { name, content, httpEquiv }) => {
        if (!name && !content && !httpEquiv)
            return metaStr; // do not create empty <meta> tags
        const nameStr = name ? ` name="${name}"` : '', httpEquivStr = httpEquiv ? ` http-equiv="${httpEquiv}"` : '', contentStr = content ? ` content="${content}"` : '';
        return metaStr + `<meta${nameStr}${httpEquivStr}${contentStr}>\n`;
    }, '');
}
function createScriptTags(scripts) {
    return scripts.reduce((scriptStr, { body }) => scriptStr + `<script type="application/ld+json">${body}</script>\n`, '');
}
function createLinkTags(links) {
    return links.reduce((linkStr, { href, rel, as, fetchpriority }) => {
        const relStr = rel ? ` rel="${rel}"` : '', asStr = as ? ` as="${as}"` : '', fetchStr = fetchpriority ? ` fetchpriority="${fetchpriority}"` : '';
        return linkStr + `<link href="${href}"${relStr}${asStr}${fetchStr}>\n`;
    }, '');
}
function createStyleTags(styles) {
    return styles.reduce((styleStr, { body, id }) => {
        const idStr = id ? ` id="${id}"` : '';
        return styleStr + `<style type="text/css"${idStr}>${body}</style>\n`;
    }, '');
}
/**
 * Serialize SsrDataResponse.markup into an HTML string
 * @param results An array of responses from getServerData hooks
 * @returns A string of HTML generated from markup metadata
 */
export function createHeadMarkup(results) {
    // Loop through the <title>, <script>, <meta>, and <link> tag information
    // Create an HTML string for each tag
    let hasTitle = false;
    return results.reduce((str, { markup: { title, scripts = [], meta = [], links = [], styles = [] } = {} }) => {
        if (title && !hasTitle) {
            // first <title> wins
            hasTitle = true;
            str += `<title>${title}</title>\n`;
        }
        return (str +
            createMetaTags(meta) +
            createScriptTags(scripts) +
            createLinkTags(links) +
            createStyleTags(styles));
    }, '');
}
/**
 * Serialize SsrDataResponse.markup into HTML, then add it to the <head> of a base doc
 * @param results An array of responses from getServerData hooks
 * @param stringBuilder The string builder for a base document
 */
export function addHeadMarkup(results, stringBuilder) {
    // Create HTML tags for each item in the SsrDataResponse.markup bag
    const headMarkup = createHeadMarkup(Object.values(results));
    if (headMarkup) {
        // Add all the links to the <head> section of the base document
        const headIndex = stringBuilder.original.indexOf('</head>');
        if (headIndex >= 0) {
            stringBuilder.prependLeft(headIndex, headMarkup);
        }
        else {
            logger.error('Adding markup during server-side rendering failed. Could not find the </head> tag.');
        }
    }
}
//# sourceMappingURL=utils.js.map