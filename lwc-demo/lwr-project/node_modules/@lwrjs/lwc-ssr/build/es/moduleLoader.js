import path from 'path';
import crypto from 'crypto';
import { getTracer } from '@lwrjs/instrumentation';
import { explodeSpecifier, getLocalDevOverrideUrl, getSpecifier, isLocalDev } from '@lwrjs/shared-utils';
import { FetchController, createFetchEndowment, getLoaderConfig, getLoaderId, getLoaderShim, } from './utils.js';
export const FETCH_ABORT_KEY = '__fetchAbortId__';
const BOOTSTRAP_SPECIFIER = '@lwrjs/ssr-bootstrap';
export function createModuleLoader(config, resourceRegistry, bundleRegistry, runtimeEnvironment, runtimeParams, serverData, bootstrapConfig) {
    const createLoader = runtimeEnvironment.format === 'amd' ? createAMDModuleLoader : createESMModuleLoader;
    return createLoader(config, resourceRegistry, bundleRegistry, runtimeEnvironment, runtimeParams, serverData, bootstrapConfig);
}
async function createAMDModuleLoader(config, resourceRegistry, bundleRegistry, runtimeEnvironment, runtimeParams, serverData, bootstrapConfig) {
    // creating a render context to avoid polluting globals
    const loaderConfig = getLoaderConfig(BOOTSTRAP_SPECIFIER, config, runtimeParams, serverData);
    const { context, controller } = createContext(loaderConfig, runtimeParams);
    const contextKeyMap = new Map(Object.keys(context).map((key) => [key, true]));
    // attaching custom init to delay bootstrap module evaluation
    let run;
    context.LWR.customInit = async (lwr) => {
        run = lwr.initializeApp;
    };
    // instantiate modules with shadowed globals
    const useEval = process.env.SSR_DEBUG === 'true';
    const init = (source) => {
        if (!useEval) {
            const fn = new Function('globalThis', ...Object.keys(context), source);
            fn(context, ...Object.values(context));
        }
        else {
            // use eval to ensure source map line numbers are correct for debugging
            ((context) => {
                eval(`${Object.keys(context).reduce((c, k) => c + `const ${k} = context['${k}'];`, 'globalThis=context;')} ${source}`);
            })(context);
        }
    };
    // load and instantiate the loader shim
    init(await getLoaderShim(resourceRegistry, runtimeEnvironment, bootstrapConfig));
    if (!run) {
        throw new Error('Failed to init loader shim: custom init not called');
    }
    // manually define bootstrap module to export the loader
    const p = new Promise((resolve) => {
        context.LWR.define(BOOTSTRAP_SPECIFIER, [getLoaderId(context.LWR, bootstrapConfig)], (l) => resolve(l));
    });
    // execute the bootstrap module
    run();
    // loader API should be available after bootstrap module evaluation
    const { load, services, clearRegistry } = await p;
    // todo: could this use the loader's module cache?
    const visited = new Set(['lwc']);
    return {
        services,
        clearRegistry,
        load: async (specifier, aliases) => {
            const injectBundle = async (bundle, aliases) => {
                if (visited.has(bundle) && specifier !== bundle) {
                    return;
                }
                visited.add(bundle);
                const moduleId = explodeSpecifier(bundle);
                const def = await bundleRegistry.getModuleBundle(moduleId, runtimeEnvironment, runtimeParams);
                if (typeof def.src === 'string' && !def.code.includes('//# sourceURL=')) {
                    // @view bundles are stored in a special location during local-dev
                    const srcUrl = isLocalDev()
                        ? getLocalDevOverrideUrl(config.cacheDir, moduleId.specifier, def.src)
                        : def.src;
                    def.code += `\n//# sourceURL=${path.resolve(srcUrl)}`;
                }
                const staticImports = def.bundleRecord.imports?.map((dep) => getSpecifier(dep)) ?? [];
                const dynamicImports = def.bundleRecord.dynamicImports?.map((dep) => getSpecifier(dep)) ?? [];
                if (staticImports.length || dynamicImports.length) {
                    // Can running these in parallel bite us on expected ordering?  Especially for externals
                    await Promise.all([...staticImports, ...dynamicImports].map((dep) => injectBundle(dep)));
                }
                // inject the bundle into the loader's module registry
                init(def.code);
                // TODO: fix duplicate aliases problem
                // create aliases
                if (aliases?.length) {
                    for (const alias of aliases) {
                        context.LWR.define(alias, [def.id], (mod) => mod);
                        context.LWR.define(getSpecifier({
                            specifier: alias,
                            version: def.version,
                        }), [def.id], (mod) => mod);
                    }
                }
                // TODO: remove this once we confirm it's no longer needed in CLWR
                if (def.specifier.startsWith('@app') || def.specifier.startsWith('@salesforce')) {
                    context.LWR.define(getSpecifier(def), [def.specifier], (mod) => mod);
                }
                return def;
            };
            // load and inject the module graph
            const injected = await injectBundle(specifier, aliases);
            if (!injected) {
                throw new Error(`Failed to inject bundle ${specifier}`);
            }
            // "dynamically" load and evaluate the module
            const mod = await load(injected.id);
            return {
                specifier: injected.specifier,
                module: mod,
            };
        },
        getFetchController: () => controller,
        resetGlobalContext: () => {
            // Clear the context of all of the keys that may be added by module evaluation.
            // Do not delete keys that we added ourselves.
            for (const key in context) {
                if (Object.prototype.hasOwnProperty.call(context, key) && !contextKeyMap.has(key)) {
                    delete context[key];
                }
            }
            // Reset LWR globals as needed.
            // Note: we only need to reset serverData today, since it is the only
            // property that mutates between page renders.
            context.LWR = {
                ...context.LWR,
                serverData: undefined,
            };
        },
        // Note: only used for testing
        getContext: () => {
            return context;
        },
    };
}
async function createESMModuleLoader() {
    throw new Error('ESM support coming soon.');
}
/**
 * Create a context object that mimics the `globalThis` object in the browser environment.  The object
 * contains polyfills for missing browser APIs and overrides select APIs, like `fetch`.
 *
 * @param LWR - client bootstrap config
 * @param runtimeParams - request parameters
 * @returns a `globalThis` object
 */
function createContext(LWR, runtimeParams) {
    // todo: fetch endowment should consume tracer directly
    const tracer = getTracer();
    const trace = tracer.trace.bind(tracer);
    const fetchEndowment = createFetchEndowment(trace, runtimeParams.host, runtimeParams.requestDepth);
    const fetchController = new FetchController(fetchEndowment);
    const context = {
        LWR,
        lwcRuntimeFlags: { ENABLE_WIRE_SYNC_EMIT: true },
        // browser api polyfills
        crypto,
        CustomEvent: Event,
        // global fetch api override
        fetch: fetchController.controlledFetch,
    };
    return {
        context,
        controller: {
            enableNoOpFetch: () => {
                fetchController.activateNoOp();
            },
            disableNoOpFetch: () => {
                fetchController.deactivateNoOp();
            },
            enableFetchKillSwitch: () => {
                fetchController.activateKillSwitch();
            },
            disableFetchKillSwitch: () => {
                fetchController.deactivateKillSwitch();
            },
        },
    };
}
//# sourceMappingURL=moduleLoader.js.map