import type { ClientBootstrapConfig, EnvironmentContext, LwrStringBuilder, NormalizedLwrAppBootstrapConfig, NormalizedLwrErrorRoute, NormalizedLwrRoute, ProviderAppConfig, PublicResourceRegistry, RuntimeEnvironment, RuntimeParams, ServerData, SsrDataResponse } from '@lwrjs/types';
import { TraceFn } from '@lwrjs/instrumentation';
interface ServerEnvironment extends EnvironmentContext {
    SSR: boolean;
}
export declare const SSR_PROPS_ATTR = "data-lwr-props-id";
export declare function getPropsId(): string;
export declare function getRenderTimeout(): number;
export declare function createSsrErrorMessage(specifier: string, e: any): string;
export declare function getLoaderShim(resourceRegistry: PublicResourceRegistry, runtimeEnvironment: RuntimeEnvironment, bootstrapConfig: NormalizedLwrAppBootstrapConfig): Promise<string>;
export declare function getLoaderId(config: ClientBootstrapConfig, bootstrapConfig: NormalizedLwrAppBootstrapConfig): string;
export declare function getLoaderConfig(bootstrapModule: string, config: ProviderAppConfig, runtimeParams: RuntimeParams, serverData: ServerData): ClientBootstrapConfig & {
    env: ServerEnvironment;
};
export declare function getServerBootstrapServices(route: NormalizedLwrRoute | NormalizedLwrErrorRoute): string[];
export type FetchFunction = (request: string | URL | globalThis.Request, init?: RequestInit) => Promise<Response>;
/**
 * During SSR a context is created with a new fetchController. At this point any fetches work as expected in this context.
 *
 * Right before renderComponents we call activateNoOp. At this point any new fetch calls in this context result in a no-op
 * fetch waiting to be aborted.
 *
 * When SSR for this request is complete we call activateKillSwitch which aborts any pending fetch calls in this context.
 * Any new fetch calls (i.e. from other async function calls) would be immediately aborted.
 */
export declare class FetchController {
    private killSwitchActivated;
    private noOpActivated;
    private controllers;
    private fetchEndowment;
    constructor(fetchEndowment: FetchFunction);
    controlledFetch: FetchFunction;
    /**
     * After SSR is complete the kill switch will abort any pending fetch requests.
     */
    activateKillSwitch: () => void;
    deactivateKillSwitch: () => void;
    /**
     * During SSR renderComponent (which is synchronous) Do not even call any fetch requests
     * since they would not complete before SSR is done.
     */
    activateNoOp: () => void;
    deactivateNoOp: () => void;
    private handleAbortError;
    /**
     * Create a fetch API that never calls a request.
     * This is not expected to be called without an AbortController setup.
     */
    private fetchNoOp;
}
export declare function createFetchEndowment(trace: TraceFn<Response>, host?: string, requestCount?: number): FetchFunction;
/**
 * Serialize SsrDataResponse.markup into an HTML string
 * @param results An array of responses from getServerData hooks
 * @returns A string of HTML generated from markup metadata
 */
export declare function createHeadMarkup(results: SsrDataResponse[]): string;
/**
 * Serialize SsrDataResponse.markup into HTML, then add it to the <head> of a base doc
 * @param results An array of responses from getServerData hooks
 * @param stringBuilder The string builder for a base document
 */
export declare function addHeadMarkup(results: SsrDataResponse[], stringBuilder: LwrStringBuilder): void;
export {};
//# sourceMappingURL=utils.d.ts.map