// TODO: investigate perf impact W-16056356
import { LRUCache } from 'lru-cache';
import { LwrUnresolvableError, createSingleDiagnosticError, descriptions, logger, stringifyError, } from '@lwrjs/diagnostics';
import { buildEnvironmentContext, getCacheKeyFromJson, getSpecifier, isLambdaEnv, moduleSpecifierToKebabCase, getFeatureFlags, TaskPool, } from '@lwrjs/shared-utils';
import { ViewSpan, getTracer } from '@lwrjs/instrumentation';
import { getServerBootstrapServices, getRenderTimeout } from './utils.js';
import { createModuleLoader } from './moduleLoader.js';
import { createServerBootstrapServices, evaluateServerBootstrapModule } from './serverBootstrapServices.js';
let singleton;
/**
 * Get a renderer singleton
 *
 * @param bundleRegistry
 * @param resourceRegistry
 * @returns singleton
 */
export function getRenderer(config, bundleRegistry, resourceRegistry) {
    // todo: reset singleton on file change for local dev
    if (!singleton) {
        singleton = new Renderer(config, bundleRegistry, resourceRegistry);
    }
    return singleton;
}
export class Renderer {
    constructor(config, bundleRegistry, resourceRegistry) {
        this.config = config;
        this.bundleRegistry = bundleRegistry;
        this.resourceRegistry = resourceRegistry;
        // Prevent number of cached contexts from growing unbounded.
        // In reality, the number of env permutations should be relatively small
        this.contextPerEnv = new LRUCache({
            max: 50,
            dispose: () => {
                logger.info('evicted bootstrap context from renderer cache');
            },
        });
        // TODO: remove the task pool altogether once W-16104831 and W-16047359 are resolved.
        // Until the above issues are resolved, we can only handle one request at a time.
        // Since Lambda's can only handle 1 request at a time anyways, this is fine for now.
        const taskPoolSize = getFeatureFlags().SINGLE_RENDER_MODE ? 1 : 15;
        this.pendingRenders = new TaskPool(taskPoolSize);
    }
    /**
     * Render components to HTML strings
     *
     * @remarks
     * The rendering flow is as follows:
     *  1. invoke `getServerData`
     *  2. execute the route's SSR bootstrap services
     *  3. render the component to HTML
     *
     * @param components - group of components to render
     * @param route - route configuration
     * @param runtimeEnvironment - environment context
     * @param runtimeParams - request context
     * @param serverData - render data TODO serverData is modified (add test?)
     * @returns render results and errors per component
     */
    async render(components, route, runtimeEnvironment, runtimeParams, serverData = {}, isFirstOf2PassSSR) {
        let result;
        // Only use a timeout when running in a lambda environment or if we've manually specified a timeout (for local testing purposes)
        if (isLambdaEnv() || process.env.SSR_TIMEOUT !== undefined) {
            let timerId;
            const timeout = new Promise((_, reject) => {
                timerId = setTimeout(() => {
                    reject(createSingleDiagnosticError({
                        description: descriptions.UNRESOLVABLE.SSR_TIMEOUT(route.id, getRenderTimeout()),
                    }, LwrUnresolvableError));
                }, getRenderTimeout());
            });
            result = (await this.pendingRenders.execute(async () => {
                return Promise.race([
                    timeout,
                    // todo: abort the render if timeout occurs
                    this.renderComponents(components, route, runtimeEnvironment, runtimeParams, serverData, isFirstOf2PassSSR),
                ]);
            }));
            clearTimeout(timerId);
        }
        else {
            result = (await this.pendingRenders.execute(async () => {
                return this.renderComponents(components, route, runtimeEnvironment, runtimeParams, serverData, isFirstOf2PassSSR);
            }));
        }
        return result;
    }
    async renderComponents(components, route, runtimeEnvironment, runtimeParams, serverData = {}, isFirstOf2PassSSR = false) {
        const results = {};
        const errors = {};
        const roots = Object.keys(components);
        const services = getServerBootstrapServices(route);
        // TODO: not needed once W-16104831 is resolved
        const reevaluateModules = getFeatureFlags().REEVALUATE_MODULES === true;
        const singleRenderMode = getFeatureFlags().SINGLE_RENDER_MODE;
        let loader, loaderPromise, bootstrapServiceEvaluationMap;
        try {
            // We want a new context (and cache it for re-use) for each LWR env context.
            // E.g. if we `env.basePath: '/'` vs `env.basePath: '/foo` will result
            // in the new contexts created and used for by the renderer.
            //
            // TODO: W-16104831: when `REEVALUATE_MODULES` is enabled, we only have a single context/loader, regardless of env
            const bootstrapContext = this.getCachedBootstrapContext(route, runtimeEnvironment, runtimeParams, serverData, reevaluateModules);
            loaderPromise = bootstrapContext.loader;
            bootstrapServiceEvaluationMap = bootstrapContext.bootstrapServiceEvaluationMap;
            loader = await loaderPromise;
            // Re-enable fetch that was disabled at the end of the previous page render via `enableFetchKillSwitch`
            loader.getFetchController().disableFetchKillSwitch();
            // load and alias the LWC server engine
            // this MUST be done first in case bootstrap services depend on LWC
            const engineServerSpecifier = getSpecifier({
                specifier: '@lwc/engine-server',
                version: route.bootstrap.lwcVersion,
            });
            const engine = await loader.load(engineServerSpecifier, ['lwc']);
            // By default, we only run bootstrap services once per page render.
            const shouldRunBootstrapServices = !bootstrapServiceEvaluationMap?.has(route.id);
            let serverBootstrapServices;
            if (shouldRunBootstrapServices) {
                bootstrapServiceEvaluationMap?.set(route.id, true);
                // bootstrap services MUST load/evaluate before any module resolution (except LWC)
                // this ensures any loader `resolveHook` is registered first
                const serviceModules = await Promise.all(services.map((specifier) => loader?.load(specifier)));
                // set up the server-side Service API for the loader
                serverBootstrapServices = createServerBootstrapServices(loader);
                // evaluate the default function from each service module, passing in the Service API
                // this is where the loader and server data hooks are set
                for (const service of serviceModules) {
                    // eslint-disable-next-line
                    const error = await evaluateServerBootstrapModule(service, serverBootstrapServices.serviceAPI);
                    if (error) {
                        errors[service.specifier] = error;
                    }
                }
            }
            // load root component modules (and dependencies ofc)
            const componentModules = await Promise.all(roots.map((specifier) => loader?.load(specifier)));
            // get server data
            for (const component of componentModules) {
                const { props } = components[component.specifier];
                if (!component.module.getServerData) {
                    results[component.specifier] = { props };
                    continue;
                }
                const context = {
                    props,
                    url: runtimeParams.url,
                    params: runtimeParams.params || {},
                    query: runtimeParams.query || {},
                    locale: runtimeParams.locale || runtimeEnvironment.i18n?.defaultLocale,
                    basePath: runtimeParams.basePath || runtimeEnvironment.basePath,
                };
                // eslint-disable-next-line
                const { data, error } = await getServerData(component, context, serverData);
                if (error) {
                    errors[component.specifier] = error;
                    continue;
                }
                if (data) {
                    results[component.specifier] = data;
                }
            }
            if (serverBootstrapServices) {
                // now that we have server data, run the server data hooks
                serverBootstrapServices.evaluateServerDataHooks(serverData);
            }
            // exit early when preloading data
            if (!route.bootstrap.ssr) {
                if (Object.keys(errors).length) {
                    return { results, errors };
                }
                return { results };
            }
            // TODO: W-16047359 - reactivate this outside of the Lambda
            if (getFeatureFlags().SINGLE_RENDER_MODE) {
                // Disable async APIs before rendering components
                loader.getFetchController().enableNoOpFetch();
            }
            // render components
            for (const component of componentModules) {
                // skip rendering if an error has already occurred for the component
                if (errors[component.specifier]) {
                    continue;
                }
                const { html, error } = renderToString(engine.module, component, results[component.specifier].props);
                if (error) {
                    errors[component.specifier] = error;
                    continue;
                }
                results[component.specifier].html = html;
            }
            if (Object.keys(errors).length) {
                return { results, errors };
            }
            return { results };
        }
        catch (e) {
            const error = Object(e);
            return {
                errors: {
                    [roots.join(',')]: error.message ?? stringifyError(e),
                },
            };
        }
        finally {
            // TODO: W-16047359 - remove this check
            if (singleRenderMode) {
                loader?.getFetchController().disableNoOpFetch();
                // activate fetch controller kill switch
                loader?.getFetchController().enableFetchKillSwitch();
            }
            // At the end of 2-pass SSR, clean up for the next page render
            if (!isFirstOf2PassSSR) {
                // since we have a single global context that is maintained across page renders,
                // we need to clean it up so that state such as globalThis.LWR.serverData is not preserved
                loader?.resetGlobalContext();
                // TODO: not needed once W-16104831 is resolved
                // When `REEVALUATE_MODULES` is enabled, we clear the loader's module registry + bootstrap services
                // at the end of every render so that module state is not preserved.
                if (reevaluateModules) {
                    // clear bootstrap services so that next page render can call bootstrap services again
                    bootstrapServiceEvaluationMap?.delete(route.id);
                    loader?.clearRegistry();
                }
            }
        }
    }
    getCachedBootstrapContext(route, runtimeEnvironment, runtimeParams, serverData, reevaluateModules) {
        let loader, bootstrapServiceEvaluationMap;
        // when `REEEVALUTE_MODULES` is true, we only have a single context/loader, regardless of the env
        if (reevaluateModules) {
            if (!this.cachedBootstrapContext) {
                this.cachedBootstrapContext = {
                    loader: createModuleLoader(this.config, this.resourceRegistry, this.bundleRegistry, runtimeEnvironment, runtimeParams, serverData, route.bootstrap),
                    bootstrapServiceEvaluationMap: new Map(),
                };
            }
            return this.cachedBootstrapContext;
        }
        // The cache key is derived from LWR env context AND the host header,
        // because we associate the host header to each fetch context.
        const envContext = buildEnvironmentContext(runtimeParams);
        const { host, requestDepth } = runtimeParams;
        const contextCacheKey = getCacheKeyFromJson({ envContext, host, requestDepth });
        const bootstrapContext = this.contextPerEnv.get(contextCacheKey);
        if (!bootstrapContext) {
            loader = createModuleLoader(this.config, this.resourceRegistry, this.bundleRegistry, runtimeEnvironment, runtimeParams, serverData, route.bootstrap);
            bootstrapServiceEvaluationMap = new Map();
            this.contextPerEnv.set(contextCacheKey, {
                loader,
                bootstrapServiceEvaluationMap,
            });
        }
        else {
            loader = bootstrapContext.loader;
            bootstrapServiceEvaluationMap = bootstrapContext.bootstrapServiceEvaluationMap;
        }
        return {
            loader: loader,
            bootstrapServiceEvaluationMap,
        };
    }
}
/**
 *
 * @param component
 * @param context
 * @param serverData modifies server data
 * @returns
 */
function getServerData(component, context, serverData) {
    return getTracer().trace({
        name: ViewSpan.GetServerData,
        attributes: { specifier: component.specifier },
    }, async () => {
        try {
            const data = await component.module.getServerData(context);
            Object.assign(serverData, data.props);
            return { data };
        }
        catch (e) {
            const message = `Error in "getServerData" for "${component.specifier}": ${stringifyError(e)}`;
            logger.error(message);
            return { error: message };
        }
    });
}
function renderToString(engine, component, props) {
    return getTracer().trace({
        name: ViewSpan.RenderComponent,
        attributes: { specifier: component.specifier },
    }, () => {
        try {
            const html = engine.renderComponent(moduleSpecifierToKebabCase(component.specifier), component.module.default, props);
            return { html };
        }
        catch (e) {
            const error = Object(e);
            // add the LWC rendering stack to the error message
            const message = error.message ?? stringifyError(e);
            const detailedMessage = error.wcStack
                ? 'An error occurred during server-side rendering for component stack: ' +
                    error.wcStack +
                    '. Error was: ' +
                    message
                : `An error occurred during server-side rendering "${component.specifier}": ` + message;
            logger.error(detailedMessage);
            return { error: detailedMessage };
        }
    });
}
//# sourceMappingURL=renderer.js.map