import { logger } from '@lwrjs/diagnostics';
import { VERSION_SIGIL, explodeSpecifier, getSpecifier, isLambdaEnv } from '@lwrjs/shared-utils';
import path from 'path';
import fs from 'fs-extra';
import { getSiteBundleId, parseSiteId, resolveStaticBundleVersion } from '../site-metadata.js';
export default class StaticBundleProvider {
    constructor(_config, context) {
        this.name = 'static-bundle-provider';
        if (!context.siteMetadata) {
            throw new Error(`[${this.name}] Site metadata was not found`);
        }
        this.siteMetadata = context.siteMetadata;
        this.siteRootDir = context.siteMetadata.getSiteRootDir();
        this.bundleConfig = context.config.bundleConfig;
        this.i18n = context.config.i18n;
    }
    async bundle(moduleId, runtimeEnvironment, runtimeParams) {
        const { specifier, name, namespace, version } = moduleId;
        const { debug, i18n: { defaultLocale }, } = runtimeEnvironment;
        const localeId = (runtimeParams?.locale || defaultLocale);
        const metadata = this.getBundleMetadata(moduleId, localeId, debug);
        if (!metadata) {
            return undefined;
        }
        // Default bundle source path
        const bundlePath = path.join(this.siteRootDir, metadata.path);
        // Get the associated bundle source code
        const code = await this.getCode(bundlePath, debug, specifier, version, localeId);
        const imports = metadata.imports.map((importSpecifier) => this.getModuleReference(importSpecifier, localeId, debug));
        const dynamicImports = metadata.dynamicImports?.map((importSpecifier) => this.getModuleReference(importSpecifier, localeId, debug));
        const id = getSpecifier(moduleId);
        const exploded = explodeSpecifier(id);
        // Seem unlikely name was not in the moduleId but just incase set it form the exploded id
        const resolvedName = name ?? exploded.name;
        const resolvedNamespace = namespace ?? exploded.namespace;
        const resolvedVersion = resolveStaticBundleVersion(metadata.version, version);
        const includedModules = metadata.includedModules?.map((includedId) => {
            const includedModule = this.getModuleReference(includedId, localeId, debug);
            return getSpecifier(includedModule);
        }) || [];
        return {
            code,
            id: getSpecifier({
                specifier: specifier,
                version: resolvedVersion,
                name: resolvedName,
                namespace: resolvedNamespace,
            }),
            name: resolvedName,
            namespace: resolvedNamespace,
            version: resolvedVersion,
            specifier: specifier,
            config: this.bundleConfig,
            integrity: metadata.integrity,
            bundleRecord: {
                // TODO we need to solve include modules for fingerprints support
                includedModules,
                imports,
                dynamicImports,
            },
            src: bundlePath,
        };
    }
    getBundleMetadata(moduleId, localeId, debug) {
        const siteBundleId = getSiteBundleId(moduleId, localeId, this.i18n);
        return this.siteMetadata.getSiteBundlesDecisionTree().find(siteBundleId, debug);
    }
    /**
     * Takes a key from the site bundle metadata and creates an appropriate runtime BaseModuleReference to use in the LWR runtime.
     */
    getModuleReference(siteBundleIdStr, localeId, debug) {
        const siteBundleId = parseSiteId(siteBundleIdStr);
        const includedModule = explodeSpecifier(siteBundleId.specifier);
        if (!siteBundleId.variants[VERSION_SIGIL]) {
            const importBundleMetadata = this.siteMetadata
                .getSiteBundlesDecisionTree()
                .find(siteBundleIdStr, debug, localeId);
            includedModule.version = resolveStaticBundleVersion(importBundleMetadata?.version);
        }
        else {
            includedModule.version = siteBundleId.variants[VERSION_SIGIL];
        }
        return includedModule;
    }
    /**
     * Get the source code for the a static bundle
     * If we are running in a lambda and the mode is debug we will return the prod source code instead of the debug source code
     *
     * @param bundlePath The default path for the bundle for prod read from .metadata/bundle-metadata.json, for debug .metadata/bundle-metadata-debug.json
     * @param debug Is the request in debug mode?
     * @param specifier Root specifier for the requested bundle
     * @param localeId Locale id (e.g. en-US) for the current request
     */
    async getCode(bundlePath, debug, specifier, version, localeId) {
        // Flag is used to indicate that we are running on a lambda
        const isLambda = isLambdaEnv();
        // Default source code path determined from metadata based on debug mode
        let bundleSourcePath = bundlePath;
        try {
            // This is the special case where the request is in debug mode and we are on the lambda
            // So we will look up the prod source code instead of the debug source code
            if (debug && isLambda) {
                const metadata = this.getBundleMetadata({ specifier, version }, localeId, false);
                if (!metadata) {
                    // We did not find the bundle prod bundle even though we did find it in the debug metadata before
                    logger.warn({
                        label: 'static-bundle-provider',
                        message: `Unexpected code reference: ${specifier}`,
                    });
                    // Returning source code that throws and error is someone tries to evaluate it
                    return `throw new Error('Unexpected code reference: ${specifier}');`;
                }
                // Overwrite the default source code path the prod source code path
                bundleSourcePath = path.join(this.siteRootDir, metadata.path);
            }
            // Read the bundle source code.
            return await fs.readFile(bundleSourcePath, 'utf-8');
        }
        catch (err) {
            // Ran it an un-expected error reading the bundle source code
            logger.warn({
                label: 'static-bundle-provider',
                message: `Unexpected code reference: ${specifier} ${bundleSourcePath}`,
            }, err);
            // Returning source code that throws and error is someone tries to evaluate it
            return `throw new Error('Unexpected code reference: ${specifier} ${bundleSourcePath}');`;
        }
    }
}
//# sourceMappingURL=static-bundle-provider.js.map