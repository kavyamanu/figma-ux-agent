import type { AbstractModuleId, BundleDefinition, BundleProvider, ProviderContext, RuntimeEnvironment, RuntimeParams, SiteBundle, SiteMetadata } from '@lwrjs/types';
export default class StaticBundleProvider implements BundleProvider {
    name: string;
    siteRootDir: string;
    bundleConfig: import("@lwrjs/types").BundleConfig;
    i18n: import("@lwrjs/types").I18NConfig;
    siteMetadata: SiteMetadata;
    constructor(_config: {}, context: ProviderContext);
    bundle<BundleIdentifier extends AbstractModuleId, RE extends RuntimeEnvironment>(moduleId: BundleIdentifier, runtimeEnvironment: RE, runtimeParams: RuntimeParams): Promise<BundleDefinition | undefined>;
    getBundleMetadata(moduleId: Partial<AbstractModuleId>, localeId: string, debug: boolean): SiteBundle | undefined;
    /**
     * Takes a key from the site bundle metadata and creates an appropriate runtime BaseModuleReference to use in the LWR runtime.
     */
    private getModuleReference;
    /**
     * Get the source code for the a static bundle
     * If we are running in a lambda and the mode is debug we will return the prod source code instead of the debug source code
     *
     * @param bundlePath The default path for the bundle for prod read from .metadata/bundle-metadata.json, for debug .metadata/bundle-metadata-debug.json
     * @param debug Is the request in debug mode?
     * @param specifier Root specifier for the requested bundle
     * @param localeId Locale id (e.g. en-US) for the current request
     */
    getCode(bundlePath: string, debug: boolean, specifier: string, version: string | undefined, localeId: string): Promise<string>;
}
//# sourceMappingURL=static-bundle-provider.d.ts.map